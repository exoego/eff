<!doctype html>
<html lang="ja">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>eff - Member implicits</title>

    <link href="./css/bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <link href="./css/prettify.css" type="text/css" rel="stylesheet"/>
    <link href="./css/specs2.css" type="text/css" rel="stylesheet"/>

    <script src="./javascript/prettify.js" type="text/javascript"></script>
    <script src="./javascript/specs2.js" type="text/javascript"></script>
</head>
<body>

<div class="container">
    <div class="col-md-9 col-sm-9 col-xs-9 col-md-push-3 col-sm-push-3 col-xs-push-3">
        <h1>Member implicits</h1>
        <div id="tipue_search_content"></div>

        <p>Type inference with the Eff monad can be a bit tricky to get right if we want to avoid type annotations. Here
            are some tips to help you.</p>
        <h3 id="running-effects-with-several-type-parameters">Running effects with several type parameters</h3>
        <p>Some effects use 2 type variables, like <code class="prettyprint">Reader</code> or <code class="prettyprint">Writer</code>.
            If you want to use those effects in an effect stack you need to make sure you have the following <code
                    class="prettyprint">scalac</code> option:</p>
        <div class="sourceCode" id="cb1">
            <pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1"
                                                                                             aria-hidden="true"
                                                                                             tabindex="-1"></a>scalacOptions += <span
                    class="st">&quot;-Ypartial-unification&quot;</span></span></code></pre>
        </div>
        <h3 id="use-context-bounds-and-type-aliases">Use context bounds and type aliases</h3>
        <p>When creating effects you can always “require” a stack containing the right effects with the <code
                class="prettyprint">MemberIn</code> typeclass:</p>
        <pre><code class="prettyprint">import org.atnos.eff._
import org.atnos.eff.all._

type StateInt[A] = State[Int, A]
type WriterString[A] = Writer[String, A]

// for creating state effects
def putAndTell[R](i: Int)(implicit s: StateInt |= R, w: WriterString |= R): Eff[R, Int] =
  for {
    // no type annotations needed!
    _ &lt;- put(i)
    _ &lt;- tell(&quot;stored &quot; + i)
  } yield i</code></pre>
        <p>You can even use context bounds to make the declaration of <code class="prettyprint">putAndTell</code> more
            concise:</p>
        <pre><code class="prettyprint">import org.atnos.eff.all._

type _stateInt[R] = State[Int, *] |= R
type _writerString[R] = Writer[String, *] |= R

def putAndTell[R :_stateInt :_writerString](i: Int): Eff[R, Int] =
  for {
    _ &lt;- put(i)
    _ &lt;- tell(&quot;stored &quot; + i)
  } yield i</code></pre>
        <h3 id="know-your-member-typeclasses">Know your <code class="prettyprint">Member</code> typeclasses</h3>
        <p>There are 3 different ways to declare that an effect is part of an effect stack with 3 typeclasses:</p>
        <table>
            <colgroup>
                <col style="width: 16%"/>
                <col style="width: 7%"/>
                <col style="width: 29%"/>
                <col style="width: 47%"/>
            </colgroup>
            <thead>
            <tr class="header">
                <th>Typeclass</th>
                <th>Alias</th>
                <th>Meaning</th>
                <th>When to use it</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
                <td><code class="prettyprint">MemberIn[M, R]</code></td>
                <td><code class="prettyprint">M |= R</code></td>
                <td>“<code class="prettyprint">M</code> is part of <code class="prettyprint">R</code>”</td>
                <td>to create <code class="prettyprint">M</code> effects in <code class="prettyprint">R</code></td>
            </tr>
            <tr class="even">
                <td><code class="prettyprint">MemberInOut[M, R]</code></td>
                <td><code class="prettyprint">M /= R</code></td>
                <td>“<code class="prettyprint">M</code> is part of <code class="prettyprint">R</code> and can be
                    extracted from it”
                </td>
                <td>to intercept the effect <code class="prettyprint">M</code> (see <code class="prettyprint">Interpreter.scala</code>)
                    and transform it while staying in the same stack. For example to <code class="prettyprint">handleError</code>
                    for an Error effect
                </td>
            </tr>
            <tr class="odd">
                <td><code class="prettyprint">Member[M, R]</code></td>
                <td><code class="prettyprint">M &lt;= R</code></td>
                <td>“<code class="prettyprint">M</code> is part of <code class="prettyprint">R</code>, can be extracted
                    from it, and the resulting stack is <code class="prettyprint">m.Out</code>”
                </td>
                <td>to interpret the effect in terms of special values or other effects and remove the effect from the
                    stack
                </td>
            </tr>
            </tbody>
        </table>
        <h3 id="packing-member-instances">“Packing” member instances</h3>
        <p>Some function signatures can be repetitive when they always require the same list of effects:</p>
        <p>def foo1<a href="i:%20Int">R :_foo :_bar :_baz</a>: Eff[R, Int] def foo2<a href="i:%20Int">R :_foo :_bar
            :_baz</a>: Eff[R, Int] def foo3<a href="i:%20Int">R :_foo :_bar :_baz</a>: Eff[R, Int]</p>
        <p>It is possible to “pack” them with the following <code class="prettyprint">_effects</code> type definition:
        </p>
        <pre><code class="prettyprint">import org.atnos.eff.Members.{&amp;:, &amp;&amp;:}

trait Foo[A]
trait Bar[A]
trait Baz[A]
trait Boo[A]

type _foo[R] = Foo |= R
type _bar[R] = Bar |= R
type _baz[R] = Baz |= R

// Note the last &amp;&amp;:, you can write instead: _foo[R] &amp;: _bar[R] &amp;: _baz[R] &amp;: NoMember
type _effects[R] = _foo[R] &amp;: _bar[R] &amp;&amp;: _baz[R]

def getFoo[R :_foo :_bar]: Eff[R, Int] = Eff.pure(1)
def getBar[R :_bar]: Eff[R, Int] = Eff.pure(1)
def getBaz[R :_baz]: Eff[R, Int] = Eff.pure(1)

object t {

  import org.atnos.eff.Members.extractMember

  def foo[R :_effects](i: Int): Eff[R, Int] =
    getFoo[R] &gt;&gt;
    getBar[R] &gt;&gt;
    getBaz[R]

}

// Then call foo with a concrete stack
type S = Fx.fx3[Foo, Bar, Baz]
type U = Fx.fx4[Foo, Bar, Baz, Boo]

t.foo[S](1)
t.foo[U](1)</code></pre>
        <p>The implicit definition <code class="prettyprint">extractMember</code> in the <code class="prettyprint">Members</code>
            object will take care of “unpacking” the member instances where required. Note that this implicit must <em>not</em>
            be in scope when calling the methods requiring the “packed” implicits otherwise it will trigger a divergent
            implicit search.</p>
    </div>

    <div class="col-md-3 col-sm-3 col-xs-3 col-md-pull-9 col-sm-pull-9 col-xs-pull-9 sidebar-outer">
    </div>
</div>

</body>
</html>
